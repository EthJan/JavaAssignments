import java.io.*;
 import java.math.BigDecimal;
 import java.math.RoundingMode;
 import java.util.Scanner;
 /*optimize function */abstract class ObjectiveFunction {abstract double compute(double[] variables); abstract double[] computeGradient(double[] variables); abstract double[] getBounds(); abstract String getName(); abstract double computeTolerance(double[] gradient);} class QuadraticFunction extends ObjectiveFunction { @Override double compute(double[] variables) { double result = 0.0; for (double variable : variables) { result += variable * variable; } return result; } @Override double[] computeGradient(double[] variables) { double[] gradient = new double[variables.length]; int i = 0; for (double variable : variables) { gradient[i] = 2 * variable; i++; } return gradient; } @Override double[] getBounds() { double bounds[] = {-5, 5}; return bounds; } @Override String getName() { return "Quadratic"; } @Override double computeTolerance(double[] gradient) { double sumOfSquares = 0.0; for (double component : gradient) { sumOfSquares += component * component; } return Math.sqrt(sumOfSquares); } } class RosenbrockFunction extends ObjectiveFunction { @Override double compute(double[] variables) { double result = 0.0; for (int i = 0; i < (variables.length - 1); i++) { result += 100 * Math.pow(variables[i + 1] - (variables[i] * variables[i]), 2) + (Math.pow((1 - variables[i]), 2)); } return result; } @Override double[] computeGradient(double[] variables) { double[] gradient = new double[variables.length]; for (int i = 0; i < variables.length -1; i++){ gradient[i] = -400 * variables[i] * (variables[i+1] - Math.pow(variables[i], 2)) - 2 * (1 - variables[i]); } gradient[variables.length -1] = 200 * (variables[variables.length -1] - Math.pow(variables[variables.length -2], 2)); return gradient; } @Override double[] getBounds() { double bounds[] = {-5, 5}; return bounds; } @Override String getName() { return "Rosenbrock"; } @Override double computeTolerance(double[] gradient) { double sumOfSquares = 0.0; for (double component : gradient) { sumOfSquares += component * component; } return Math.sqrt(sumOfSquares); } } class RosenbrockBonusFunction extends ObjectiveFunction { @Override double compute(double[] variables) { double result = 0.0; for (int i = 0; i < (variables.length - 1); i++) { result += 100 * Math.pow(variables[i + 1] - (variables[i] * variables[i]), 2) + (Math.pow((1 - variables[i]), 2)); } return result; } @Override double[] computeGradient(double[] variables) { double[] gradient = new double[variables.length]; gradient[0] = -400 * variables[0] * (variables[1] - Math.pow(variables[0], 2)) - 2 * (1 - variables[0]); for (int i = 1; i < variables.length - 1; i++) { gradient[i] = 200 * (variables[i] - Math.pow(variables[i - 1], 2)) - 400 * variables[i] * (variables[i + 1] - Math.pow(variables[i], 2)) - 2 * (1 - variables[i]); } gradient[variables.length -1] = 200 * (variables[variables.length -1] - Math.pow(variables[variables.length -2], 2)); return gradient; } @Override double[] getBounds() { double bounds[] = {-5, 5}; return bounds; } @Override String getName() { return "Rosenbrock_Bonus"; } @Override double computeTolerance(double[] gradient) { double sumOfSquares = 0.0; for (double component : gradient) { sumOfSquares += component * component; } return Math.sqrt(sumOfSquares); } } class SteepestDescentOptimizer { static int dim, itr; static int num, in, out; static double tol, step; static double[] bounds = {-5, 5}; static String outputPath = null; static void optimizeSteepestDescent(ObjectiveFunction objectiveFunction, double[] variables, int iterations, double tolerance, double stepSize, int dimensionality) { if (out == 1) { double currentTolerance = 0; for (int i = 0; i < iterations; i++) { double gradient[] = objectiveFunction.computeGradient(variables); System.out.println("\nIteration " + (i + 1) + ":"); System.out.printf("Objective Function Value: %.5f\n", floorTo5Decimals(objectiveFunction.compute(variables))); System.out.print("x-values: "); for (double variable : variables) { System.out.printf("%.5f ", variable); } if (i > 0) { System.out.printf("\nCurrent Tolerance:  %.5f", floorTo5Decimals(currentTolerance)); if (currentTolerance < tolerance) { System.out.println("\n\nConvergence reached after " + (i + 1) + " iterations."); break; } System.out.println(""); } else { System.out.println(""); } currentTolerance = objectiveFunction.computeTolerance(gradient); for (int j = 0; j < dim; j++) { variables[j] += (stepSize * -gradient[j]); variables[j] = floorTo5Decimals(variables[j]); } if (i + 1 == iterations) { System.out.println("\nMaximum iterations reached without satisfying the tolerance."); } } System.out.println("\nOptimization process completed."); } else if (out == 0) { try { BufferedWriter writer = new BufferedWriter(new FileWriter(outputPath, true)); try { double currentTolerance = 0; for (int i = 0; i < iterations; i++) { double gradient[] = objectiveFunction.computeGradient(variables); writer.write("\nIteration " + (i + 1) + ":"); writer.write(String.format("\nObjective Function Value: %.5f\n", floorTo5Decimals(objectiveFunction.compute(variables)))); writer.write("x-values: "); for (double variable : variables) { writer.write(String.format("%.5f ", variable)); } if (i > 0) { writer.write(String.format("\nCurrent Tolerance:  %.5f", floorTo5Decimals(currentTolerance))); if (currentTolerance < tolerance) { writer.newLine(); writer.newLine(); writer.write("Convergence reached after " + (i + 1) + " iterations."); break; } writer.newLine(); } else { writer.newLine(); } currentTolerance = objectiveFunction.computeTolerance(gradient); for (int j = 0; j < dim; j++) { variables[j] += (stepSize * -gradient[j]); variables[j] = floorTo5Decimals(variables[j]); } if (i + 1 == iterations) { writer.newLine(); writer.write("Maximum iterations reached without satisfying the tolerance."); } } writer.newLine(); writer.newLine(); writer.write("Optimization process completed."); } catch (IOException e) { System.out.println("Error: Failed to create output file."); System.exit(0); } writer.close(); } catch (IOException e) { } } } private static double floorTo5Decimals(double value) { BigDecimal bd = new BigDecimal(value).setScale(5, RoundingMode.FLOOR); return bd.doubleValue(); } static void getManualInput(Scanner input) { String function; System.out.println("Enter the choice of objective function (quadratic or rosenbrock): "); function = input.nextLine(); System.out.println("Enter the dimensionality of the problem: "); dim = Integer.parseInt(input.nextLine()); System.out.println("Enter the number of iterations:"); itr = Integer.parseInt(input.nextLine()); System.out.println("Enter the tolerance:"); tol = Double.parseDouble(input.nextLine()); System.out.println("Enter the step Size: "); step = Double.parseDouble(input.nextLine()); if (out == 0) { System.out.println("Please provide the path for the output file:"); outputPath = input.nextLine(); } if (function.equals("quadratic")) { double[] variables = new double[dim]; String line; while (true) { System.out.println("Enter the initial point as " + dim + " space seperated values: "); line = input.nextLine(); String[] proper = line.split(" "); if (dim == proper.length) { for (int i = 0; i < dim; i++) { variables[i] = Double.parseDouble(proper[i]); } break; } else { System.out.println("Error: Initial point dimensionality mismatch."); System.exit(0); } } checkBounds(variables, bounds); QuadraticFunction quadratic = new QuadraticFunction(); System.out.println("Objective Function: " + quadratic.getName()); ManualInputTemplate(variables); optimizeSteepestDescent(quadratic, variables, itr, tol, step, dim); } else if (function.equals("rosenbrock")) { double[] variables = new double[dim]; String line; System.out.println("Enter the initial point as " + dim + " space seperated values: "); line = input.nextLine(); String[] proper = line.split(" "); if (dim == proper.length) { for (int i = 0; i < dim; i++) { variables[i] = Double.parseDouble(proper[i]); } } else { System.out.println("Error: Initial point dimensionality mismatch."); System.exit(0); } checkBounds(variables, bounds); RosenbrockFunction rosenbrock = new RosenbrockFunction(); System.out.println("Objective Function: " + rosenbrock.getName()); ManualInputTemplate(variables); optimizeSteepestDescent(rosenbrock, variables, itr, tol, step, dim); } else if (function.equals("rosenbrock_bonus")) { double[] variables = new double[dim]; String line; System.out.println("Enter the initial point as " + dim + " space seperated values: "); line = input.nextLine(); String[] proper = line.split(" "); if (dim == proper.length) { for (int i = 0; i < dim; i++) { variables[i] = Double.parseDouble(proper[i]); } } else { System.out.println("Error: Initial point dimensionality mismatch."); System.exit(0); } checkBounds(variables, bounds); RosenbrockBonusFunction rosenbrock_bonus = new RosenbrockBonusFunction(); System.out.println("Objective Function: " + rosenbrock_bonus.getName()); ManualInputTemplate(variables); optimizeSteepestDescent(rosenbrock_bonus, variables, itr, tol, step, dim); } else { System.out.println("Error: unknown objective function"); } } static void ManualInputTemplate(double[] variables) { System.out.println("Dimensionality: " + dim); System.out.print("Initial Point: "); for (double variable : variables) { System.out.print(variable + " "); } System.out.printf("\nIterations: %d", itr); System.out.printf("\nTolerance: %.5f ", floorTo5Decimals(tol)); System.out.printf("\nStep Size: %.5f", floorTo5Decimals(step)); System.out.print("\n\nOptimization Process:"); } static void getFileInput(Scanner input) { System.out.println("Please provide the path to the config file:"); String inputPath = input.nextLine(); try { BufferedReader reader = new BufferedReader(new FileReader(inputPath)); String function = null; String readLine; if ((readLine = reader.readLine()) != null && (readLine.equals("quadratic") || readLine.equals("rosenbrock") || readLine.equals("rosenbrock_bonus"))) { function = readLine; } else { System.out.println("Error: Unknown objective function."); System.exit(0); } dim = Integer.parseInt(reader.readLine()); itr = Integer.parseInt(reader.readLine()); tol = Double.parseDouble(reader.readLine()); step = Double.parseDouble(reader.readLine()); double[] variables = new double[dim]; String line = reader.readLine(); String[] proper = line.split(" "); if (dim == proper.length) { for (int i = 0; i < dim; i++) { variables[i] = Double.parseDouble(proper[i]); } } else { System.out.println("Error: Initial point dimensionality mismatch."); System.exit(0); } checkBounds(variables, bounds); if (out == 0) { System.out.println("Please provide the path for the output file:"); outputPath = input.nextLine(); } if (function.equals("quadratic")) { QuadraticFunction quadratic = new QuadraticFunction(); reader.close(); try { BufferedWriter writer = new BufferedWriter(new FileWriter(outputPath)); writer.write("Objective Function: " + quadratic.getName()); writer.newLine(); writer.close(); FileInputTemplate(variables); optimizeSteepestDescent(quadratic, variables, itr, tol, step, dim); } catch (IOException e) { System.out.println("Error writing file."); } } else if (function.equals("rosenbrock_bonus")) { RosenbrockBonusFunction rosenbrock_bonus = new RosenbrockBonusFunction(); reader.close(); try { BufferedWriter writer = new BufferedWriter(new FileWriter(outputPath)); writer.write("Objective Function: " + rosenbrock_bonus.getName()); writer.newLine(); writer.close(); FileInputTemplate(variables); optimizeSteepestDescent(rosenbrock_bonus, variables, itr, tol, step, dim); writer.close(); } catch (IOException e) { System.out.println("Error writing the file."); } } else if (function.equals("rosenbrock")) { RosenbrockFunction rosenbrock = new RosenbrockFunction(); reader.close(); try { BufferedWriter writer = new BufferedWriter(new FileWriter(outputPath)); writer.write("Objective Function: " + rosenbrock.getName()); writer.newLine(); writer.close(); FileInputTemplate(variables); optimizeSteepestDescent(rosenbrock, variables, itr, tol, step, dim); } catch (IOException e) { System.out.println("Error writing file."); } } else { System.out.println("Error: Unknown objective function."); System.exit(0); } } catch (IOException e) { System.out.println("Error reading the file."); } } static void FileInputTemplate(double[] variables) { try { BufferedWriter writer = new BufferedWriter(new FileWriter(outputPath, true)); writer.write("Dimensionality: " + dim); writer.newLine(); writer.write("Initial Point: "); for (double variable : variables) { writer.write(variable + " "); } writer.newLine(); writer.write("Iterations: " + itr); writer.newLine(); writer.write(String.format("Tolerance: %.5f", floorTo5Decimals(tol))); writer.newLine(); writer.write(String.format("Step Size: %.5f", floorTo5Decimals(step))); writer.newLine(); writer.newLine(); writer.write("Optimization Process:"); writer.close(); } catch (IOException e) { System.out.println("Error writing file."); } } static void checkBounds(double[] variables, double[] bounds) { for (double var : variables) { if (var < bounds[0] || var > bounds[1]) { System.out.println("Error: Initial point " + var + " is outside the bounds [-5.0,5.0]."); System.exit(0); } } } static int getValidatedInput(Scanner input, String message) { System.out.println(message); try { num = Integer.parseInt(input.nextLine()); } catch (NumberFormatException e) { System.out.println("Please enter a valid input (0 or 1)."); return 1000; } return num; } public static void mainCode() { String prompt; Scanner input = new Scanner(System.in); while (true) { prompt = "Press 0 to exit or 1 to enter the program: "; num = getValidatedInput(input, prompt); if (num == 1) { break; } else if (num == 0) { System.out.println("Exiting program..."); break; } } if (num == 1) { while (true) { prompt = "Press 0 for .txt input or 1 for manual input: "; in = getValidatedInput(input, prompt); if (in == 1 || in == 0) { break; } } while (true) { prompt = "Press 0 for .txt output or 1 for console output: "; out = getValidatedInput(input, prompt); if (out == 1 || out == 0) { break; } } if (in == 0) { getFileInput(input); } else if (in == 1) { getManualInput(input); } } input.close(); } } public class he { public static void main(String[] args) { SteepestDescentOptimizer.mainCode(); } }
